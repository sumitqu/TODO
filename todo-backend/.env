MONGODB_URI=mongodb://localhost:27017/todo
PORT=3000
<script>
  const API_BASE = 'http://localhost:3000/api/tasks'; // Backend URL

  const taskInput = document.getElementById('taskInput');
  const addBtn = document.getElementById('addBtn');
  const taskList = document.getElementById('taskList');
  const counts = document.getElementById('counts');
  const clearAll = document.getElementById('clearAll');
  const clearCompleted = document.getElementById('clearCompleted');
  const search = document.getElementById('search');
  const chips = document.querySelectorAll('.chip');
  const priority = document.getElementById('priority');
  const due = document.getElementById('due');

  let filter = 'all';

  async function fetchTasks() {
    try {
      const res = await fetch(API_BASE);
      if (!res.ok) throw new Error('Failed to fetch tasks');
      return await res.json();
    } catch (err) {
      console.error(err);
      return [];
    }
  }

  async function addTaskToBackend(task) {
    try {
      const res = await fetch(API_BASE, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(task),
      });
      if (!res.ok) throw new Error('Failed to add task');
      return await res.json();
    } catch (err) {
      console.error(err);
    }
  }

  async function deleteTaskFromBackend(id) {
    try {
      const res = await fetch(`${API_BASE}/${id}`, { method: 'DELETE' });
      if (!res.ok) throw new Error('Failed to delete task');
    } catch (err) {
      console.error(err);
    }
  }

  async function toggleTaskCompletion(id, done) {
    try {
      const res = await fetch(`${API_BASE}/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ done }),
      });
      if (!res.ok) throw new Error('Failed to update task');
    } catch (err) {
      console.error(err);
    }
  }

  async function render() {
    const tasks = await fetchTasks();
    taskList.innerHTML = ''; // Clear the list
    const q = search.value.trim().toLowerCase();
    const today = new Date().toISOString().slice(0, 10);
    const visible = tasks.filter((t) => {
      if (filter === 'active' && t.done) return false;
      if (filter === 'completed' && !t.done) return false;
      if (filter === 'today' && t.due !== today) return false;
      if (q && !t.text.toLowerCase().includes(q)) return false;
      return true;
    });

    if (visible.length === 0) {
      document.getElementById('emptyMsg').style.display = 'block';
    } else {
      document.getElementById('emptyMsg').style.display = 'none';
    }

    visible.forEach((t) => {
      const el = document.createElement('div');
      el.className = 'task';
      const left = document.createElement('div');
      left.className = 'left';

      const cb = document.createElement('div');
      cb.className = 'checkbox' + (t.done ? ' checked' : '');
      cb.title = 'Toggle completed';
      cb.addEventListener('click', async () => {
        await toggleTaskCompletion(t._id, !t.done);
        render();
      });

      const textWrap = document.createElement('div');
      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = t.text;
      if (t.done) title.style.textDecoration = 'line-through';

      const meta = document.createElement('div');
      meta.className = 'meta';
      const parts = [];
      if (t.due) parts.push('Due: ' + t.due);
      parts.push('Priority: ' + t.priority);
      meta.textContent = parts.join(' â€¢ ');

      textWrap.appendChild(title);
      textWrap.appendChild(meta);
      left.appendChild(cb);
      left.appendChild(textWrap);

      const actions = document.createElement('div');
      actions.className = 'actions';

      const del = document.createElement('button');
      del.className = 'icon-btn';
      del.textContent = 'Delete';
      del.addEventListener('click', async () => {
        await deleteTaskFromBackend(t._id);
        render();
      });

      actions.appendChild(del);

      el.appendChild(left);
      el.appendChild(actions);
      taskList.appendChild(el);
    });

    counts.textContent = tasks.length + ' task' + (tasks.length === 1 ? '' : 's');
  }

  addBtn.addEventListener('click', async () => {
    const task = {
      text: taskInput.value,
      priority: priority.value,
      due: due.value,
    };
    await addTaskToBackend(task);
    taskInput.value = '';
    due.value = '';
    priority.value = 'normal';
    render();
  });

  chips.forEach((c) =>
    c.addEventListener('click', () => {
      chips.forEach((x) => x.classList.remove('active'));
      c.classList.add('active');
      filter = c.dataset.filter;
      render();
    })
  );

  clearAll.addEventListener('click', async () => {
    const tasks = await fetchTasks();
    for (const task of tasks) {
      await deleteTaskFromBackend(task._id);
    }
    render();
  });

  clearCompleted.addEventListener('click', async () => {
    const tasks = await fetchTasks();
    for (const task of tasks.filter((t) => t.done)) {
      await deleteTaskFromBackend(task._id);
    }
    render();
  });

  search.addEventListener('input', () => render());

  // Initial render
  render();
</script>